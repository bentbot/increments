"use strict";
var es6_promise_1 = require('es6-promise');
var http = require('http');
var url = require('url');
var angularWaits = require('./angular/wait.js');
/**
 * The stability proxy is an http server responsible for intercepting
 * JSON webdriver commands. It keeps track of whether the page under test
 * needs to wait for page stability, and initiates a wait if so.
 */
var BlockingProxy = (function () {
    function BlockingProxy(seleniumAddress, rootElement) {
        // The ng-app root to use when waiting on the client.
        this.rootElement = '';
        this.ng12hybrid = false;
        this.seleniumAddress = seleniumAddress;
        this.rootElement = rootElement || 'body';
        this.stabilityEnabled = true;
        this.server = http.createServer(this.requestListener.bind(this));
    }
    BlockingProxy.prototype.waitForAngularData = function () {
        return JSON.stringify({
            script: 'return (' + angularWaits.NG_WAIT_FN + ').apply(null, arguments);',
            args: [this.rootElement, this.ng12hybrid]
        });
    };
    /**
     * This command is for the proxy server, not to be forwarded to Selenium.
     */
    BlockingProxy.isProxyCommand = function (commandPath) {
        return (commandPath.split('/')[1] === 'stabilize_proxy');
    };
    /**
     * Create the WebDriver protocol URL for the executeAsync command.
     *
     * @param {string} originalUrl The URL from the incoming command.
     */
    BlockingProxy.executeAsyncUrl = function (originalUrl) {
        var parts = originalUrl.split('/');
        return [parts[0], parts[1], parts[2], 'execute_async'].join('/');
    };
    /**
     * Return true if the requested method should trigger a stabilize first.
     *
     * @param {string} commandPath Original request url.
     */
    BlockingProxy.prototype.shouldStabilize = function (commandPath) {
        if (!this.stabilityEnabled) {
            return false;
        }
        if (BlockingProxy.isProxyCommand(commandPath)) {
            return false;
        }
        // TODO - should this implement some state, and be smart about whether
        // stabilization is necessary or not? Would that be as simple as GET/POST?
        // e.g. two gets in a row don't require a wait btwn.
        //
        // See https://code.google.com/p/selenium/wiki/JsonWireProtocol for
        // descriptions of the paths.
        // We shouldn't stabilize if we haven't loaded the page yet.
        var parts = commandPath.split('/');
        if (parts.length < 4) {
            return false;
        }
        var commandsToWaitFor = [
            'executeScript', 'screenshot', 'source', 'title', 'element', 'elements', 'execute', 'keys',
            'moveto', 'click', 'buttondown', 'buttonup', 'doubleclick', 'touch', 'get'
        ];
        if (commandsToWaitFor.indexOf(parts[3]) != -1) {
            return true;
        }
        return false;
    };
    /**
     * Creates a request to forward to the Selenium server. The request stream
     * will not be ended - the user will need to write any data and then call
     * `.end`.
     *
     * @param {string} method
     * @param {string} messageUrl
     * @param {function(http.IncomingMessage)} callback
     *
     * @return {http.ClientRequest}
     */
    BlockingProxy.prototype.createSeleniumRequest = function (method, messageUrl, callback) {
        var parsedUrl = url.parse(this.seleniumAddress);
        var options = {};
        options['method'] = method;
        options['path'] = parsedUrl.path + messageUrl;
        options['hostname'] = parsedUrl.hostname;
        options['port'] = parsedUrl.port;
        var request = http.request(options, callback);
        return request;
    };
    ;
    BlockingProxy.prototype.handleProxyCommand = function (message, data, response) {
        var command = message.url.split('/')[2];
        switch (command) {
            case 'enabled':
                if (message.method === 'GET') {
                    response.writeHead(200);
                    response.write(JSON.stringify({ value: this.stabilityEnabled }));
                    response.end();
                }
                else if (message.method === 'POST') {
                    response.writeHead(200);
                    this.stabilityEnabled = JSON.parse(data).value;
                    response.end();
                }
                else {
                    response.writeHead(405);
                    response.write('Invalid method');
                    response.end();
                }
                break;
            case 'selenium_address':
                if (message.method === 'GET') {
                    response.writeHead(200);
                    response.write(JSON.stringify({ value: this.seleniumAddress }));
                    response.end();
                }
                else if (message.method === 'POST') {
                    response.writeHead(200);
                    this.seleniumAddress = JSON.parse(data).value;
                    response.end();
                }
                else {
                    response.writeHead(405);
                    response.write('Invalid method');
                    response.end();
                }
                break;
            default:
                response.writeHead(404);
                response.write('Unknown stabilizer proxy command');
                response.end();
        }
    };
    BlockingProxy.prototype.sendRequestToStabilize = function (originalRequest) {
        var _this = this;
        var self = this;
        console.log('Waiting for stability...', originalRequest.url);
        var deferred = new es6_promise_1.Promise(function (resolve, reject) {
            var stabilityRequest = self.createSeleniumRequest('POST', BlockingProxy.executeAsyncUrl(originalRequest.url), function (stabilityResponse) {
                // TODO - If the response is that angular is not available on the
                // page, should we just go ahead and continue?
                var stabilityData = '';
                stabilityResponse.on('data', function (data) {
                    stabilityData += data;
                });
                stabilityResponse.on('error', function (err) {
                    console.log(err);
                    reject(err);
                });
                stabilityResponse.on('end', function () {
                    var value = JSON.parse(stabilityData).value;
                    if (value) {
                        // waitForAngular only returns a value if there was an error
                        // in the browser.
                        // TODO(heathkit): Extract more useful information from
                        // webdriver errors.
                        console.log('Error while waiting for page to stabilize: ', value['localizedMessage']);
                        reject(value);
                    }
                    resolve();
                });
            });
            stabilityRequest.write(_this.waitForAngularData());
            stabilityRequest.end();
        });
        return deferred;
    };
    BlockingProxy.prototype.requestListener = function (originalRequest, response) {
        var self = this;
        var stabilized = es6_promise_1.Promise.resolve(null);
        if (BlockingProxy.isProxyCommand(originalRequest.url)) {
            var commandData_1 = '';
            originalRequest.on('data', function (d) {
                commandData_1 += d;
            });
            originalRequest.on('end', function () {
                self.handleProxyCommand(originalRequest, commandData_1, response);
            });
            return;
        }
        // If the command is not a proxy command, it's a regular webdriver command.
        if (self.shouldStabilize(originalRequest.url)) {
            stabilized = self.sendRequestToStabilize(originalRequest);
        }
        stabilized.then(function () {
            var seleniumRequest = self.createSeleniumRequest(originalRequest.method, originalRequest.url, function (seleniumResponse) {
                response.writeHead(seleniumResponse.statusCode, seleniumResponse.headers);
                seleniumResponse.pipe(response);
            });
            originalRequest.pipe(seleniumRequest);
        }, function (err) {
            response.writeHead(500);
            response.write(err);
            response.end();
        });
    };
    BlockingProxy.prototype.listen = function (port) {
        this.server.listen(port);
        var actualPort = this.server.address().port;
        console.log('Blocking proxy listening on port ' + actualPort);
        return actualPort;
    };
    BlockingProxy.prototype.quit = function () {
        var _this = this;
        return new es6_promise_1.Promise(function (resolve) {
            _this.server.close(resolve);
        });
    };
    return BlockingProxy;
}());
exports.BlockingProxy = BlockingProxy;
//# sourceMappingURL=blockingproxy.js.map